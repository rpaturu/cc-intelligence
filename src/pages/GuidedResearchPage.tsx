import { useState, useRef, useEffect } from "react";
import { Button } from "../components/ui/button";
import { Card, CardContent } from "../components/ui/card";
import { Input } from "../components/ui/input";
import { Avatar, AvatarFallback } from "../components/ui/avatar";
import { Send, Search, Users, Target, CheckCircle, Zap, MessageSquare, TrendingUp, Eye } from "lucide-react";
import Navbar from "../components/Navbar";
import { useAuth } from "../hooks/useAuth";
import { useProfile } from "../hooks/useProfile";
import { vendorContext } from "../lib/api";
import { Message, CompanySummary, ResearchProgress } from "../types/research-types";
import { getResearchAreas, CORE_RESEARCH_AREAS } from "../data";
import { createVendorProfile } from "../utils";
import { getResearchFindings, getMockSources } from "../utils/researchFindings";
import { MessageBubble, ExportResearchSheet } from "../components/widgets";
import { generatePersonalizedWelcome, getWelcomeSources } from "../utils/personalizedWelcome";

export function GuidedResearchPage() {
  const { user } = useAuth();
  const { profile } = useProfile();
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [currentCompany, setCurrentCompany] = useState<string>("");
  const [completedResearchIds, setCompletedResearchIds] = useState<string[]>([]);
  const [activeTabsState, setActiveTabsState] = useState<Record<string, string>>({});
  const [highlightedSource, setHighlightedSource] = useState<number | null>(null);
  const [isExportSheetOpen, setIsExportSheetOpen] = useState(false);
  const [completedResearch, setCompletedResearch] = useState<any[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  const handleCitationClick = (messageId: string, sourceId: number) => {
    setActiveTabsState(prev => ({
      ...prev,
      [messageId]: "sources"
    }));
    
    setHighlightedSource(sourceId);
    
    setTimeout(() => {
      setHighlightedSource(null);
    }, 3000);
  };

  const handleExportResearch = () => {
    setIsExportSheetOpen(true);
  };

  const handleDownloadReport = (format: 'pdf' | 'powerpoint' | 'word' | 'excel' | 'json' = 'json') => {
    const reportData = {
      company: currentCompany,
      generatedBy: `${profile?.name || user?.email?.split('@')[0] || 'User'}`,
      generatedAt: new Date().toISOString(),
      completedResearch: completedResearch,
      summary: `Research report for ${currentCompany} generated by ${profile?.name || user?.email?.split('@')[0] || 'User'} on ${new Date().toLocaleDateString()}`
    };

    let content: string;
    let mimeType: string;
    let fileExtension: string;
    const fileName = currentCompany.replace(/\s+/g, '_');

    switch (format) {
      case 'pdf':
        content = generatePDFContent(reportData);
        mimeType = 'application/pdf';
        fileExtension = 'pdf';
        break;
      case 'powerpoint':
        content = generatePowerPointContent(reportData);
        mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
        fileExtension = 'pptx';
        break;
      case 'word':
        content = generateWordContent(reportData);
        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        fileExtension = 'docx';
        break;
      case 'excel':
        content = generateExcelContent(reportData);
        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        fileExtension = 'xlsx';
        break;
      case 'json':
      default:
        content = JSON.stringify(reportData, null, 2);
        mimeType = 'application/json';
        fileExtension = 'json';
        break;
    }

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName}_research_report.${fileExtension}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Generate content for different formats (simplified versions for demo)
  const generatePDFContent = (data: any): string => {
    // In a real implementation, you'd use a library like jsPDF or PDFKit
    return `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>
endobj
4 0 obj
<< /Length 44 >>
stream
BT
/F1 12 Tf
72 720 Td
(Research Report for ${data.company}) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000208 00000 n 
trailer
<< /Size 5 /Root 1 0 R >>
startxref
309
%%EOF`;
  };

  const generatePowerPointContent = (data: any): string => {
    // In a real implementation, you'd use a library like PptxGenJS
    const slides = [
      `Research Report: ${data.company}`,
      `Generated by: ${data.generatedBy}`,
      `Date: ${new Date(data.generatedAt).toLocaleDateString()}`,
      ...data.completedResearch.map((research: any) => `${research.title}: ${research.findings.items.length} findings`)
    ];
    
    return `[PowerPoint Content]
Title: Research Report - ${data.company}
Slides: ${slides.length}
Content: ${slides.join('\n')}`;
  };

  const generateWordContent = (data: any): string => {
    // In a real implementation, you'd use a library like docx
    let content = `Research Report: ${data.company}\n\n`;
    content += `Generated by: ${data.generatedBy}\n`;
    content += `Date: ${new Date(data.generatedAt).toLocaleDateString()}\n\n`;
    
    data.completedResearch.forEach((research: any) => {
      content += `\n${research.title}\n`;
      content += `Completed: ${new Date(research.completedAt).toLocaleDateString()}\n\n`;
      
      research.findings.items.forEach((item: any) => {
        content += `${item.title}\n`;
        content += `${item.description}\n`;
        if (item.details) {
          item.details.forEach((detail: string) => {
            content += `• ${detail.replace(/\[\d+\]/g, '')}\n`;
          });
        }
        content += `\n`;
      });
    });
    
    return content;
  };

  const generateExcelContent = (data: any): string => {
    // In a real implementation, you'd use a library like xlsx
    let csv = `Company,Research Area,Finding,Details,Completed Date\n`;
    
    data.completedResearch.forEach((research: any) => {
      research.findings.items.forEach((item: any) => {
        const details = item.details ? item.details.join('; ').replace(/\[\d+\]/g, '') : '';
        csv += `"${data.company}","${research.title}","${item.title}","${details}","${new Date(research.completedAt).toLocaleDateString()}"\n`;
      });
    });
    
    return csv;
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Initialize with vendor profile and personalized welcome message
  useEffect(() => {
    const userCompany = profile?.company || 'your company';
    const userRole = profile?.role || 'account-executive';
    
    const vendorProfileMessage: Message = {
      id: "vendor-profile",
      type: "assistant",
      content: "",
      timestamp: new Date(),
      vendorProfile: createVendorProfile(userCompany, userRole),
    };

    const personalizedWelcomeContent = generatePersonalizedWelcome(profile, user);
    const welcomeSources = getWelcomeSources(userCompany);

    const welcomeMessage: Message = {
      id: "welcome",
      type: "assistant",
      content: personalizedWelcomeContent,
      timestamp: new Date(),
      sources: welcomeSources,
      isPersonalizedWelcome: true,
    };
    
    setMessages([vendorProfileMessage, welcomeMessage]);
  }, [user, profile]);



  const parseCompanyFromInput = (input: string): string => {
    const patterns = [
      /research\s+(.+)/i,
      /analyze\s+(.+)/i,
      /tell me about\s+(.+)/i,
      /lookup\s+(.+)/i,
      /find\s+(.+)/i,
    ];
    
    for (const pattern of patterns) {
      const match = input.match(pattern);
      if (match) {
        return match[1].trim();
}
    }
    return input.trim();
  };

  const isResearchQuery = (input: string): boolean => {
    const researchKeywords = ['research', 'analyze', 'tell me about', 'lookup', 'find', 'investigate'];
    const lowerInput = input.toLowerCase();
    return researchKeywords.some(keyword => lowerInput.includes(keyword)) || 
           lowerInput.length > 2;
  };

  const getCompanyData = async (companyName: string): Promise<CompanySummary> => {
    try {
      const response = await vendorContext(companyName);
      if (response.success && response.vendorContext) {
        const vendor = response.vendorContext;
        
        return {
          name: vendor.companyName,
          industry: vendor.industry || 'Industry not available',
          size: vendor.companySize || 'Company size not available',
          location: 'Location data not available', // TODO: Add location to vendorContext API
          recentNews: vendor.recentNews?.[0] || 'No recent news available',
          techStack: vendor.techStack || [],
        };
      }
    } catch (error) {
      console.error('Failed to get vendor context:', error);
    }
    
    // Only fallback with "not available" messaging - no fake data
    return {
      name: companyName,
      industry: 'Industry data not available',
      size: 'Company size not available',
      location: 'Location data not available',
      recentNews: 'Recent news not available',
      techStack: [],
    };
  };

  const simulateStreaming = (messageId: string, researchArea: string, areaId: string) => {
    
    // Enhanced streaming steps with specific icons matching Figma design
    const steps = [
      { 
        text: `🎯 Analyzing ${researchArea.toLowerCase()} data`, 
        completed: false, 
        icon: <Target className="w-4 h-4" />,
        type: 'analysis' as const
      },
      { 
        text: "🔍 Scanning industry reports and news", 
        completed: false, 
        icon: <Search className="w-4 h-4" />,
        type: 'research' as const
      },
      { 
        text: "📊 Reviewing investor calls and earnings", 
        completed: false, 
        icon: <TrendingUp className="w-4 h-4" />,
        type: 'data' as const
      },
      { 
        text: "👥 Identifying operational inefficiencies", 
        completed: false, 
        icon: <Users className="w-4 h-4" />,
        type: 'analysis' as const
      },
      { 
        text: `✅ Found 5 key ${researchArea.toLowerCase()} insights`, 
        completed: false, 
        icon: <CheckCircle className="w-4 h-4" />,
        type: 'completion' as const
      },
    ];
    
    setMessages(prev => prev.map(msg => 
      msg.id === messageId 
        ? { ...msg, isStreaming: true, streamingSteps: steps }
        : msg
    ));

    steps.forEach((_, index) => {
      setTimeout(() => {
        setMessages(prev => prev.map(msg => 
          msg.id === messageId && msg.streamingSteps
            ? {
                ...msg,
                streamingSteps: msg.streamingSteps.map((step, i) => 
                  i === index ? { ...step, completed: true } : step
                )
              }
            : msg
        ));
      }, (index + 1) * 1000);
    });

    setTimeout(() => {
      const findings = getResearchFindings(areaId, currentCompany);
      const sources = getMockSources(currentCompany, areaId);

      const allAreas = getResearchAreas(profile?.role || 'account-executive');
      const newCompletedIds = [...completedResearchIds, areaId];
      
      // Mark this research area as completed
      setCompletedResearchIds(newCompletedIds);
      
      // Save completed research for export
      const completedResearchData = {
        id: areaId,
        title: findings.title,
        completedAt: new Date(),
        findings: findings
      };
      setCompletedResearch(prev => [...prev, completedResearchData]);
      
      const researchProgress: ResearchProgress = {
        totalAreas: allAreas.length,
        completedAreas: newCompletedIds.length,
        completedIds: newCompletedIds,
        isCollapsed: true
      };

      // First, update the streaming message with findings (without follow-up options)
      setMessages(prev => prev.map(msg => {
        if (msg.id === messageId) {
          return { 
            ...msg, 
            isStreaming: false,
            content: "",
            researchFindings: findings,
            sources: sources
          };
        }
        return msg;
      }));
      setIsTyping(false);

      // Then, add research progress message
      setTimeout(() => {
        const progressMessageId = `progress-${Date.now()}`;
        const progressMessage: Message = {
          id: progressMessageId,
          type: "assistant",
          content: "",
          timestamp: new Date(),
          researchProgress,
          researchAreas: allAreas
        };
        
        setMessages(prev => [...prev, progressMessage]);

        // Finally, add the follow-up options message
        setTimeout(() => {
          const followUpMessageId = `followup-${Date.now()}`;
          const followUpMessage: Message = {
            id: followUpMessageId,
            type: "assistant",
            content: "",
            timestamp: new Date(),
            followUpOptions: getFollowUpOptionsForArea(areaId)
          };
          
          setMessages(prev => [...prev, followUpMessage]);
        }, 200);
      }, 500);
    }, steps.length * 1000 + 500);
  };

  const getFollowUpOptionsForArea = (areaId: string) => {
    const followUpMap: Record<string, Array<{ id: string; text: string; icon: React.ReactNode; category: string }>> = {
      "decision_makers": [
        { id: "tech_stack", text: "Research their tech stack", icon: <Zap className="w-4 h-4" />, category: "research" },
        { id: "business_challenges", text: "Identify pain points", icon: <Target className="w-4 h-4" />, category: "research" },
        { id: "create_outreach", text: "Create personalized outreach", icon: <MessageSquare className="w-4 h-4" />, category: "action" },
        { id: "export_report", text: "View Full Report", icon: <Eye className="w-4 h-4" />, category: "action" }
      ],
      "business_challenges": [
        { id: "buying_signals", text: "Look for buying signals", icon: <TrendingUp className="w-4 h-4" />, category: "research" },
        { id: "decision_makers", text: "Find decision makers", icon: <Users className="w-4 h-4" />, category: "research" },
        { id: "create_outreach", text: "Create personalized outreach", icon: <MessageSquare className="w-4 h-4" />, category: "action" },
        { id: "export_report", text: "View Full Report", icon: <Eye className="w-4 h-4" />, category: "action" }
      ]
    };

    return followUpMap[areaId] || [
      { id: "export_report", text: "View Full Report", icon: <Eye className="w-4 h-4" />, category: "action" }
    ];
  };

  const handleSendMessage = async (messageContent?: string) => {
    const messageToSend = messageContent || inputValue;
    if (!messageToSend.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      type: "user",
      content: messageToSend,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    const currentInput = messageToSend;
    setInputValue("");
    setIsTyping(true);

    setTimeout(async () => {
      const messageId = (Date.now() + 1).toString();
      
      if (isResearchQuery(currentInput)) {
        const company = parseCompanyFromInput(currentInput);
        setCurrentCompany(company);
        const companyData = await getCompanyData(company);
        
        const summaryMessage: Message = {
          id: messageId,
          type: "assistant",
          content: "",
          timestamp: new Date(),
          companySummary: companyData,
        };

        setMessages(prev => [...prev, summaryMessage]);

        setTimeout(() => {
          const newOptionsMessageId = (Date.now() + 2).toString();
          
          const allAreas = getResearchAreas(profile?.role || 'account-executive');
          
          // Full list of research areas for initial display (matches Figma order)
          const priorityAreaIds = [
            'decision_makers',
            'tech_stack', 
            'business_challenges',
            'competitive_positioning',
            'recent_activities',
            'budget_indicators',
            'buying_signals',
            'competitive_usage',
            'digital_footprint',
            'growth_signals',
            'compliance_requirements',
            'integration_needs'
          ];
          
          const priorityAreas = priorityAreaIds
            .map(id => allAreas.find(area => area.id === id))
            .filter(Boolean) as typeof allAreas;
          
          const optionsMessage: Message = {
            id: newOptionsMessageId,
            type: "assistant",
            content: `What specific aspect of ${company} would you like me to research first?`,
            timestamp: new Date(),
            options: priorityAreas.map(area => ({
              id: area.id,
              text: area.description,
              icon: area.icon
            })),
            researchAreas: allAreas,
          };

          setMessages(prev => [...prev, optionsMessage]);
          setIsTyping(false);
        }, 2000);
      } else {
        const assistantMessage: Message = {
          id: messageId,
          type: "assistant",
          content: "I can help you research companies and prospects. Try asking me to 'Research [Company Name]' to get started with comprehensive discovery.",
          timestamp: new Date(),
        };

        setMessages(prev => [...prev, assistantMessage]);
        setIsTyping(false);
      }
    }, 1000);
  };

  const handleResearchAreaClick = (areaId: string, areaTitle: string) => {
    if (areaId === "export_report") {
      handleExportResearch();
      return;
    }

    const userMessage: Message = {
      id: Date.now().toString(),
      type: "user",
      content: areaTitle,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setIsTyping(true);

    setTimeout(() => {
      const messageId = (Date.now() + 1).toString();
      
      if (CORE_RESEARCH_AREAS.some(area => area.id === areaId)) {
        const streamingMessage: Message = {
          id: messageId,
          type: "assistant",
          content: `🔍 Researching ${areaTitle.toLowerCase()}...`,
          timestamp: new Date(),
        };

        setMessages(prev => [...prev, streamingMessage]);
        simulateStreaming(messageId, areaTitle, areaId);
      } else {
        const responses = {
          "create_outreach": "I'll help you create personalized outreach based on the decision makers we found...",
          "export_report": "Opening your full research report...",
          "research_another": "What other company would you like to research?",
        };

        const assistantMessage: Message = {
          id: messageId,
          type: "assistant",
          content: responses[areaId as keyof typeof responses] || "Let me help you with that...",
          timestamp: new Date(),
        };

        setMessages(prev => [...prev, assistantMessage]);
        setIsTyping(false);
      }
    }, 1000);
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const userData = {
    firstName: profile?.name?.split(' ')[0] || user?.email?.split('@')[0] || 'User',
    lastName: profile?.name?.split(' ')[1] || '',
  };

  return (
    <div className="min-h-screen bg-background">
      <Navbar />

      {/* Export Research Sheet */}
      <ExportResearchSheet
        isOpen={isExportSheetOpen}
        onOpenChange={setIsExportSheetOpen}
        currentCompany={currentCompany}
        userName={profile?.name?.split(' ')[0] || user?.email?.split('@')[0] || 'User'}
        messages={messages}
        completedResearch={completedResearch}
        onDownloadReport={handleDownloadReport}
      />

      {/* Chat Interface */}
      <div className="max-w-4xl mx-auto px-3 sm:px-4 pb-4 pt-28 md:pt-20 min-h-screen flex flex-col">
        <div className="flex-1 overflow-y-auto space-y-3 sm:space-y-4 mb-4 pt-6 sm:pt-8">
          {messages.map((message) => (
            <MessageBubble
              key={message.id}
              message={message}
              userFirstName={userData.firstName}
              userLastName={userData.lastName}
              userRole={profile?.role || 'account-executive'}
              profile={profile}
              completedResearchIds={completedResearchIds}
              onResearchAreaClick={handleResearchAreaClick}
              onFollowUpClick={handleResearchAreaClick}
              onCitationClick={handleCitationClick}
              highlightedSource={highlightedSource}
              activeTabsState={activeTabsState}
              onTabChange={(messageId, tab) => setActiveTabsState(prev => ({ ...prev, [messageId]: tab }))}
            />
          ))}
          
          {/* Typing Indicator */}
          {isTyping && (
            <div className="flex justify-start">
              <div className="flex gap-3 max-w-3xl">
                <Avatar className="w-8 h-8 flex-shrink-0">
                  <AvatarFallback className="bg-primary text-primary-foreground text-xs">
                    AI
                  </AvatarFallback>
                </Avatar>
      <Card>
                  <CardContent className="p-3">
                    <div className="flex items-center gap-1">
                      <div className="w-2 h-2 bg-muted-foreground rounded-full animate-pulse"></div>
                      <div className="w-2 h-2 bg-muted-foreground rounded-full animate-pulse" style={{ animationDelay: "0.2s" }}></div>
                      <div className="w-2 h-2 bg-muted-foreground rounded-full animate-pulse" style={{ animationDelay: "0.4s" }}></div>
          </div>
                  </CardContent>
      </Card>
              </div>
            </div>
          )}
          
          <div ref={messagesEndRef} />
        </div>

        {/* Input Area */}
        <div className="border-t pt-3 sm:pt-4">
          <div className="flex gap-2">
            <Input
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Research a company..."
              className="flex-1 text-sm sm:text-base"
              disabled={isTyping}
            />
            <Button onClick={() => handleSendMessage()} disabled={!inputValue.trim() || isTyping} size="sm" className="px-3">
              <Send className="w-4 h-4" />
        </Button>
      </div>
          
          {/* Suggested Queries */}
          <div className="mt-2 flex flex-wrap gap-1.5 sm:gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => handleSendMessage("Research Tesla")}
              disabled={isTyping}
              className="text-xs sm:text-sm px-2 sm:px-3"
            >
              Research Tesla
            </Button>
              <Button
                variant="outline"
              size="sm"
              onClick={() => handleSendMessage("Research Shopify")}
              disabled={isTyping}
              className="text-xs sm:text-sm px-2 sm:px-3"
              >
              Research Shopify
              </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => handleSendMessage("Research Microsoft")}
              disabled={isTyping}
              className="text-xs sm:text-sm px-2 sm:px-3"
            >
              Research Microsoft
        </Button>
      </div>
         </div>
      </div>
    </div>
); 
} 