import { useState, useRef, useEffect } from "react";
import { Button } from "../components/ui/button";
import { Card, CardContent } from "../components/ui/card";
import { Input } from "../components/ui/input";
import { Avatar, AvatarFallback } from "../components/ui/avatar";
import { Send, Users, Target, Zap, MessageSquare, TrendingUp, Eye } from "lucide-react";
import Navbar from "../components/Navbar";
import { useAuth } from "../hooks/useAuth";
import { useProfile } from "../hooks/useProfile";
import { customerIntelligence } from "../lib/api";
import { Message, CompanySummary, ResearchProgress } from "../types/research-types";
import { getResearchAreas, CORE_RESEARCH_AREAS } from "../data";
import { MessageBubble, ExportResearchSheet } from "../components/widgets";
import { generatePersonalizedWelcome, getWelcomeSources } from "../utils/personalizedWelcome";
import TypingIndicator from "../features/guided/components/TypingIndicator";
import { parseCompanyFromInput, isResearchQuery } from "../features/guided/utils";
import { useGuidedIntelligence } from "../features/guided/useGuidedIntelligence";
import { runQuestion } from "../features/guided/QuestionRunner";

export function GuidedResearchPage() {
  const { user } = useAuth();
  const { profile } = useProfile();
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputValue, setInputValue] = useState("");
  const [isTyping, setIsTyping] = useState(false);
  const [currentCompany, setCurrentCompany] = useState<string>("");
  const [completedResearchIds, setCompletedResearchIds] = useState<string[]>([]);
  const [activeTabsState, setActiveTabsState] = useState<Record<string, string>>({});
  const [highlightedSource, setHighlightedSource] = useState<number | null>(null);
  const [isExportSheetOpen, setIsExportSheetOpen] = useState(false);
  const [completedResearch, setCompletedResearch] = useState<any[]>([]);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { scrollToBottom, scrollToStreamingMessage, scrollToResearchFindings } = useGuidedIntelligence(messagesEndRef);

  const handleCitationClick = (messageId: string, sourceId: number) => {
    setActiveTabsState(prev => ({
      ...prev,
      [messageId]: "sources"
    }));
    
    setHighlightedSource(sourceId);
    
    setTimeout(() => {
      setHighlightedSource(null);
    }, 3000);
  };

  const handleExportResearch = () => {
    setIsExportSheetOpen(true);
  };

  const handleDownloadReport = (format: 'pdf' | 'powerpoint' | 'word' | 'excel' | 'json' = 'json') => {
    const reportData = {
      company: currentCompany,
      generatedBy: `${profile?.name || user?.email?.split('@')[0] || 'User'}`,
      generatedAt: new Date().toISOString(),
      completedResearch: completedResearch,
      summary: `Research report for ${currentCompany} generated by ${profile?.name || user?.email?.split('@')[0] || 'User'} on ${new Date().toLocaleDateString()}`
    };

    let content: string;
    let mimeType: string;
    let fileExtension: string;
    const fileName = currentCompany.replace(/\s+/g, '_');

    switch (format) {
      case 'pdf':
        content = generatePDFContent(reportData);
        mimeType = 'application/pdf';
        fileExtension = 'pdf';
        break;
      case 'powerpoint':
        content = generatePowerPointContent(reportData);
        mimeType = 'application/vnd.openxmlformats-officedocument.presentationml.presentation';
        fileExtension = 'pptx';
        break;
      case 'word':
        content = generateWordContent(reportData);
        mimeType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
        fileExtension = 'docx';
        break;
      case 'excel':
        content = generateExcelContent(reportData);
        mimeType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        fileExtension = 'xlsx';
        break;
      case 'json':
      default:
        content = JSON.stringify(reportData, null, 2);
        mimeType = 'application/json';
        fileExtension = 'json';
        break;
    }

    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName}_research_report.${fileExtension}`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  // Generate content for different formats (simplified versions for demo)
  const generatePDFContent = (data: any): string => {
    // In a real implementation, you'd use a library like jsPDF or PDFKit
    return `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R >>
endobj
4 0 obj
<< /Length 44 >>
stream
BT
/F1 12 Tf
72 720 Td
(Research Report for ${data.company}) Tj
ET
endstream
endobj
xref
0 5
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000208 00000 n 
trailer
<< /Size 5 /Root 1 0 R >>
startxref
309
%%EOF`;
  };

  const generatePowerPointContent = (data: any): string => {
    // In a real implementation, you'd use a library like PptxGenJS
    const slides = [
      `Research Report: ${data.company}`,
      `Generated by: ${data.generatedBy}`,
      `Date: ${new Date(data.generatedAt).toLocaleDateString()}`,
      ...data.completedResearch.map((research: any) => `${research.title}: ${research.findings.items.length} findings`)
    ];
    
    return `[PowerPoint Content]
Title: Research Report - ${data.company}
Slides: ${slides.length}
Content: ${slides.join('\n')}`;
  };

  const generateWordContent = (data: any): string => {
    // In a real implementation, you'd use a library like docx
    let content = `Research Report: ${data.company}\n\n`;
    content += `Generated by: ${data.generatedBy}\n`;
    content += `Date: ${new Date(data.generatedAt).toLocaleDateString()}\n\n`;
    
    data.completedResearch.forEach((research: any) => {
      content += `\n${research.title}\n`;
      content += `Completed: ${new Date(research.completedAt).toLocaleDateString()}\n\n`;
      
      research.findings.items.forEach((item: any) => {
        content += `${item.title}\n`;
        content += `${item.description}\n`;
        if (item.details) {
          item.details.forEach((detail: string) => {
            content += `• ${detail.replace(/\[\d+\]/g, '')}\n`;
          });
        }
        content += `\n`;
      });
    });
    
    return content;
  };

  const generateExcelContent = (data: any): string => {
    // In a real implementation, you'd use a library like xlsx
    let csv = `Company,Research Area,Finding,Details,Completed Date\n`;
    
    data.completedResearch.forEach((research: any) => {
      research.findings.items.forEach((item: any) => {
        const details = item.details ? item.details.join('; ').replace(/\[\d+\]/g, '') : '';
        csv += `"${data.company}","${research.title}","${item.title}","${details}","${new Date(research.completedAt).toLocaleDateString()}"\n`;
      });
    });
    
    return csv;
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages]);

  // Initialize with personalized welcome message (Figma parity)
  useEffect(() => {
    const userCompany = profile?.company || 'your company';

    const personalizedWelcomeContent = generatePersonalizedWelcome(profile, user);
    const welcomeSources = getWelcomeSources(userCompany);

    const welcomeMessage: Message = {
      id: "welcome",
      type: "assistant",
      content: personalizedWelcomeContent,
      timestamp: new Date(),
      sources: welcomeSources,
      isPersonalizedWelcome: true,
    };
    
    setMessages([welcomeMessage]);
  }, [user, profile]);



  const getCompanyData = async (companyName: string): Promise<CompanySummary> => {
    try {
      // Use customerIntelligence API for prospect research (not vendorContext)
      const response = await customerIntelligence(companyName, profile?.company);
      if (response.success && response.customerIntelligence) {
        const customer = response.customerIntelligence;
        
        // Transform API response to our CompanySummary format
        return {
          name: customer.companyOverview.name,
          industry: customer.companyOverview.industry || 'Industry not available',
          size: customer.companyOverview.size || 'Company size not available',
          location: 'Location data not available', // TODO: Add location to customerIntelligence API
          recentNews: 'Recent news not available', // TODO: Add recent news to customerIntelligence API
          techStack: customer.contextualInsights.techStackRelevance || [],
          founded: 'Founded date not available', // TODO: Add founded date to customerIntelligence API
          revenue: 'Revenue not available', // TODO: Add revenue to customerIntelligence API
          // Enhanced fields from customer intelligence
          businessModel: customer.companyOverview.description,
          marketPosition: customer.positioningGuidance.recommendedApproach,
          keyExecutives: customer.contextualInsights.relevantDecisionMakers?.map(name => ({
            name,
            role: 'Key Decision Maker',
            background: 'Background information to be enhanced'
          })),
          recentDevelopments: customer.contextualInsights.buyingSignals?.map(signal => ({
            type: 'expansion' as const,
            title: signal,
            date: 'Recent',
            impact: 'medium' as const
          })),
          competitiveContext: {
            mainCompetitors: customer.contextualInsights.competitiveUsage || [],
            differentiators: customer.positioningGuidance.keyValueProps || [],
            challenges: customer.positioningGuidance.potentialPainPoints || []
          }
        };
      }
    } catch (error) {
      console.error('Failed to get customer intelligence:', error);
    }
    
    // Enhanced mock data for demonstration (will be replaced with real API data)
    return getEnhancedCompanyData(companyName);
  };

  const getEnhancedCompanyData = (companyName: string): CompanySummary => {
    const company = companyName.toLowerCase();
    
    // Mock customer intelligence data aligned with API structure
    if (company.includes('shopify')) {
      return {
        name: "Shopify",
        industry: "E-commerce Platform & Business Solutions",
        size: "Large Enterprise (10,000+ employees)",
        location: "Ottawa, Canada",
        recentNews: "2024: Expansion of Shopify Magic AI features",
        techStack: ["Ruby on Rails", "React", "GraphQL", "MySQL", "Redis", "Docker"],
        founded: "2006",
        revenue: "$7.1B",
        businessModel: "B2B SaaS + Transaction fees - Multi-tenant e-commerce platform serving 5.6M merchants globally",
        marketPosition: "Market leader in SMB e-commerce with growing enterprise presence. Strong position against BigCommerce and WooCommerce.",
        growthStage: "Public scale company",
        keyExecutives: [
          { name: "Tobias Lütke", role: "CEO & Co-founder", background: "Technical founder with deep product vision, leads strategic direction" },
          { name: "Amy Shapero", role: "CFO", background: "Former Google finance executive, joined 2022 to scale financial operations" },
          { name: "Kaz Nejatian", role: "VP Product", background: "Former Kash founder, driving AI and checkout innovations" }
        ],
        fundingHistory: [
          { round: "IPO", amount: "$1.3B", date: "May 2015", investors: ["NYSE: SHOP"] },
          { round: "Series C", amount: "$100M", date: "Dec 2013", investors: ["Bessemer Venture Partners", "FirstMark Capital", "Insight Venture Partners"] },
          { round: "Series B", amount: "$15M", date: "Oct 2011", investors: ["Bessemer Venture Partners", "FirstMark Capital"] },
          { round: "Series A", amount: "$7M", date: "Dec 2010", investors: ["Bessemer Venture Partners", "FirstMark Capital"] }
        ],
        businessMetrics: {
          valuation: "$65B market cap",
          employeeGrowth: "+15% YoY",
          customerCount: "5.6M merchants",
          marketShare: "10% of US e-commerce market"
        },
        recentDevelopments: [
          { type: "product", title: "Shopify Magic AI assistant launch for merchant automation", date: "Dec 2024", impact: "high" },
          { type: "expansion", title: "European POS expansion targeting offline-to-online merchants", date: "Nov 2024", impact: "medium" },
          { type: "partnership", title: "YouTube Shopping integration for social commerce", date: "Oct 2024", impact: "medium" },
          { type: "funding", title: "$2.1B invested in fulfillment network expansion", date: "Sep 2024", impact: "high" }
        ],
        competitiveContext: {
          mainCompetitors: ["Amazon Seller Central", "WooCommerce", "BigCommerce", "Magento Commerce"],
          differentiators: ["Unified commerce platform", "App ecosystem with 8,000+ apps", "Shopify Payments integrated", "Mobile-first approach"],
          challenges: ["Amazon's marketplace dominance", "Enterprise adoption vs incumbent solutions", "International payment complexities"]
        }
      };
    }
    
    if (company.includes('tesla')) {
      return {
        name: "Tesla",
        industry: "Electric Vehicles & Clean Energy",
        size: "Large Enterprise (127,855 employees)",
        location: "Austin, TX",
        recentNews: "Cybertruck production ramping up",
        techStack: ["Python", "C++", "Linux", "Custom Silicon", "AI/ML", "Neural Networks"],
        founded: "2003",
        revenue: "$96.8B",
        businessModel: "Direct-to-consumer EV manufacturing + Energy storage + Autonomous driving",
        marketPosition: "Global EV market leader with 20% market share",
        growthStage: "Public growth company",
        keyExecutives: [
          { name: "Elon Musk", role: "CEO", background: "Serial entrepreneur, SpaceX founder" },
          { name: "Drew Baglino", role: "SVP Powertrain & Energy", background: "20+ years Tesla, battery expert" },
          { name: "Lars Moravy", role: "VP Vehicle Engineering", background: "Model 3/Y chief engineer" }
        ],
        businessMetrics: {
          valuation: "$800B market cap",
          employeeGrowth: "+29% YoY",
          customerCount: "6M+ vehicles delivered",
          marketShare: "20% global EV market"
        },
        recentDevelopments: [
          { type: "product", title: "Cybertruck production begins", date: "Nov 2024", impact: "high" },
          { type: "expansion", title: "Mexico Gigafactory groundbreaking", date: "Oct 2024", impact: "high" },
          { type: "product", title: "FSD Beta v12 neural network", date: "Sep 2024", impact: "high" }
        ],
        competitiveContext: {
          mainCompetitors: ["BYD", "Volkswagen", "GM", "Ford", "Rivian"],
          differentiators: ["Supercharger network", "Full self-driving", "Manufacturing efficiency"],
          challenges: ["Chinese competition", "Traditional OEM catch-up", "Regulatory scrutiny"]
        }
      };
    }
    
    // Generic fallback for other companies
    return {
      name: companyName,
      industry: "Technology",
      size: "500 employees",
      location: "San Francisco, CA",
      recentNews: "Recent company updates",
      techStack: ["React", "Node.js", "AWS", "PostgreSQL"],
      founded: "2020",
      revenue: "$25M ARR",
      businessModel: "B2B SaaS platform",
      marketPosition: "Emerging player in the market",
      growthStage: "Scale-up (Series B)",
      keyExecutives: [
        { name: "Jane Smith", role: "CEO", background: "Former tech executive" },
        { name: "John Doe", role: "CTO", background: "Former senior engineer" }
      ],
      businessMetrics: {
        valuation: "$200M",
        employeeGrowth: "+150% YoY",
        customerCount: "2,500+ companies"
      },
      recentDevelopments: [
        { type: "funding", title: "Series B funding round", date: "Dec 2024", impact: "high" }
      ],
      competitiveContext: {
        mainCompetitors: ["Competitor A", "Competitor B"],
        differentiators: ["Key differentiator"],
        challenges: ["Market competition"]
      }
    };
  };

  const simulateStreaming = (messageId: string, researchArea: string, areaId: string) => {
    const cancel = runQuestion(
      areaId,
      researchArea,
      currentCompany,
      {
        prospectCompany: currentCompany,
        userRole: profile?.role || 'account-executive',
        vendorCompany: profile?.company,
        territory: profile?.territory,
      },
      {
        onStart: (steps) => {
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === messageId ? { ...msg, isStreaming: true, streamingSteps: steps.map((s) => ({ ...s, completed: false })) } : msg
            )
          )
          setTimeout(() => scrollToStreamingMessage(), 150)
        },
        onProgress: (stepIndex) => {
          setMessages((prev) =>
            prev.map((msg) =>
              msg.id === messageId && msg.streamingSteps
                ? {
                    ...msg,
                    streamingSteps: msg.streamingSteps.map((s, i) => (i === stepIndex ? { ...s, completed: true } : s)),
                  }
                : msg
            )
          )
        },
        onComplete: ({ findings, sources }) => {
          const allAreas = getResearchAreas(profile?.role || 'account-executive')
          const newCompletedIds = [...completedResearchIds, areaId]
          setCompletedResearchIds(newCompletedIds)
          setCompletedResearch((prev) => [
            ...prev,
            { id: areaId, title: findings.title, completedAt: new Date(), findings },
          ])

          const researchProgress: ResearchProgress = {
            totalAreas: allAreas.length,
            completedAreas: newCompletedIds.length,
            completedIds: newCompletedIds,
            isCollapsed: true,
          }

          setMessages((prev) =>
            prev.map((m) =>
              m.id === messageId
                ? { ...m, isStreaming: false, content: '', researchFindings: findings, sources }
                : m
            )
          )
          setIsTyping(false)
          setTimeout(() => scrollToResearchFindings(), 500)

          // Progress + follow-ups
          setTimeout(() => {
            const progressMessage: Message = {
              id: `progress-${Date.now()}`,
              type: 'assistant',
              content: '',
              timestamp: new Date(),
              researchProgress,
              researchAreas: allAreas,
            }
            setMessages((prev) => [...prev, progressMessage])

            setTimeout(() => {
              const followUpMessage: Message = {
                id: `followup-${Date.now()}`,
                type: 'assistant',
                content: '',
                timestamp: new Date(),
                followUpOptions: getFollowUpOptionsForArea(areaId),
              }
              setMessages((prev) => [...prev, followUpMessage])
            }, 200)
          }, 500)
        },
        onError: (error) => {
          console.error('Question run failed', error)
        },
      }
    )

    return cancel
  };

  const getFollowUpOptionsForArea = (areaId: string) => {
    const followUpMap: Record<string, Array<{ id: string; text: string; icon: React.ReactNode; category: string }>> = {
      "decision_makers": [
        { id: "tech_stack", text: "Research their tech stack", icon: <Zap className="w-4 h-4" />, category: "research" },
        { id: "business_challenges", text: "Identify pain points", icon: <Target className="w-4 h-4" />, category: "research" },
        { id: "create_outreach", text: "Create personalized outreach", icon: <MessageSquare className="w-4 h-4" />, category: "action" },
        { id: "export_report", text: "View Full Report", icon: <Eye className="w-4 h-4" />, category: "action" }
      ],
      "business_challenges": [
        { id: "buying_signals", text: "Look for buying signals", icon: <TrendingUp className="w-4 h-4" />, category: "research" },
        { id: "decision_makers", text: "Find decision makers", icon: <Users className="w-4 h-4" />, category: "research" },
        { id: "create_outreach", text: "Create personalized outreach", icon: <MessageSquare className="w-4 h-4" />, category: "action" },
        { id: "export_report", text: "View Full Report", icon: <Eye className="w-4 h-4" />, category: "action" }
      ]
    };

    return followUpMap[areaId] || [
      { id: "export_report", text: "View Full Report", icon: <Eye className="w-4 h-4" />, category: "action" }
    ];
  };

  const handleSendMessage = async (messageContent?: string) => {
    const messageToSend = messageContent || inputValue;
    if (!messageToSend.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      type: "user",
      content: messageToSend,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    const currentInput = messageToSend;
    setInputValue("");
    setIsTyping(true);

    setTimeout(async () => {
      const messageId = (Date.now() + 1).toString();
      
      if (isResearchQuery(currentInput)) {
        const company = parseCompanyFromInput(currentInput);
        setCurrentCompany(company);
        const companyData = await getCompanyData(company);
        
        const summaryMessage: Message = {
          id: messageId,
          type: "assistant",
          content: "",
          timestamp: new Date(),
          companySummary: companyData,
        };

        setMessages(prev => [...prev, summaryMessage]);

        setTimeout(() => {
          const newOptionsMessageId = (Date.now() + 2).toString();
          
          const allAreas = getResearchAreas(profile?.role || 'account-executive');
          
          // Full list of research areas for initial display (matches Figma order)
          const priorityAreaIds = [
            'decision_makers',
            'tech_stack', 
            'business_challenges',
            'competitive_positioning',
            'recent_activities',
            'budget_indicators',
            'buying_signals',
            'competitive_usage',
            'digital_footprint',
            'growth_signals',
            'compliance_requirements',
            'integration_needs'
          ];
          
          const priorityAreas = priorityAreaIds
            .map(id => allAreas.find(area => area.id === id))
            .filter(Boolean) as typeof allAreas;
          
          const optionsMessage: Message = {
            id: newOptionsMessageId,
            type: "assistant",
            content: `What specific aspect of ${company} would you like me to research first?`,
            timestamp: new Date(),
            options: priorityAreas.map(area => ({
              id: area.id,
              text: area.description,
              icon: area.icon
            })),
            researchAreas: allAreas,
          };

          setMessages(prev => [...prev, optionsMessage]);
          setIsTyping(false);
        }, 2000);
      } else {
        const assistantMessage: Message = {
          id: messageId,
          type: "assistant",
          content: "I can help you research companies and prospects. Try asking me to 'Research [Company Name]' to get started with comprehensive discovery.",
          timestamp: new Date(),
        };

        setMessages(prev => [...prev, assistantMessage]);
        setIsTyping(false);
      }
    }, 1000);
  };

  const handleResearchAreaClick = (areaId: string, areaTitle: string) => {
    if (areaId === "export_report") {
      handleExportResearch();
      return;
    }

    const userMessage: Message = {
      id: Date.now().toString(),
      type: "user",
      content: areaTitle,
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setIsTyping(true);

    setTimeout(() => {
      const messageId = (Date.now() + 1).toString();
      
      if (CORE_RESEARCH_AREAS.some(area => area.id === areaId)) {
        const streamingMessage: Message = {
          id: messageId,
          type: "assistant",
          content: `🔍 Researching ${areaTitle.toLowerCase()}...`,
          timestamp: new Date(),
        };

        setMessages(prev => [...prev, streamingMessage]);
        simulateStreaming(messageId, areaTitle, areaId);
      } else {
        const responses = {
          "create_outreach": "I'll help you create personalized outreach based on the decision makers we found...",
          "export_report": "Opening your full research report...",
          "research_another": "What other company would you like to research?",
        };

        const assistantMessage: Message = {
          id: messageId,
          type: "assistant",
          content: responses[areaId as keyof typeof responses] || "Let me help you with that...",
          timestamp: new Date(),
        };

        setMessages(prev => [...prev, assistantMessage]);
        setIsTyping(false);
      }
    }, 1000);
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSendMessage();
    }
  };

  const userData = {
    firstName: profile?.name?.split(' ')[0] || user?.email?.split('@')[0] || 'User',
    lastName: profile?.name?.split(' ')[1] || '',
  };

  return (
    <div className="min-h-screen bg-background">
      <Navbar />

      {/* Export Research Sheet */}
      <ExportResearchSheet
        isOpen={isExportSheetOpen}
        onOpenChange={setIsExportSheetOpen}
        currentCompany={currentCompany}
        userName={profile?.name?.split(' ')[0] || user?.email?.split('@')[0] || 'User'}
        messages={messages}
        completedResearch={completedResearch}
        onDownloadReport={handleDownloadReport}
      />

      {/* Chat Interface */}
      <div className="max-w-4xl mx-auto px-3 sm:px-4 pb-4 pt-28 md:pt-20 min-h-screen flex flex-col">
        <div className="flex-1 overflow-y-auto space-y-3 sm:space-y-4 mb-4 pt-6 sm:pt-8">
          {messages.map((message) => (
            <MessageBubble
              key={message.id}
              message={message}
              userFirstName={userData.firstName}
              userLastName={userData.lastName}
              userRole={profile?.role || 'account-executive'}
              profile={profile}
              completedResearchIds={completedResearchIds}
              onResearchAreaClick={handleResearchAreaClick}
              onFollowUpClick={handleResearchAreaClick}
              onCitationClick={handleCitationClick}
              highlightedSource={highlightedSource}
              activeTabsState={activeTabsState}
              onTabChange={(messageId, tab) => setActiveTabsState(prev => ({ ...prev, [messageId]: tab }))}
            />
          ))}
          
          {/* Typing Indicator */}
          {isTyping && (
            <div className="flex justify-start">
              <div className="flex gap-3 max-w-3xl items-center">
                <Avatar className="w-8 h-8 flex-shrink-0">
                  <AvatarFallback className="bg-primary text-primary-foreground text-xs">AI</AvatarFallback>
                </Avatar>
                <Card>
                  <CardContent className="p-3">
                    <TypingIndicator />
                  </CardContent>
                </Card>
              </div>
            </div>
          )}
          
          <div ref={messagesEndRef} />
        </div>

        {/* Input Area */}
        <div className="border-t pt-3 sm:pt-4">
          <div className="flex gap-2">
            <Input
              value={inputValue}
              onChange={(e) => setInputValue(e.target.value)}
              onKeyPress={handleKeyPress}
              placeholder="Research a company..."
              className="flex-1 text-sm sm:text-base"
              disabled={isTyping}
            />
            <Button onClick={() => handleSendMessage()} disabled={!inputValue.trim() || isTyping} size="sm" className="px-3">
              <Send className="w-4 h-4" />
        </Button>
      </div>
          
          {/* Suggested Queries */}
          <div className="mt-2 flex flex-wrap gap-1.5 sm:gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => handleSendMessage("Research Tesla")}
              disabled={isTyping}
              className="text-xs sm:text-sm px-2 sm:px-3"
            >
              Research Tesla
            </Button>
              <Button
                variant="outline"
              size="sm"
              onClick={() => handleSendMessage("Research Shopify")}
              disabled={isTyping}
              className="text-xs sm:text-sm px-2 sm:px-3"
              >
              Research Shopify
              </Button>
            <Button
              variant="outline"
              size="sm"
              onClick={() => handleSendMessage("Research Microsoft")}
              disabled={isTyping}
              className="text-xs sm:text-sm px-2 sm:px-3"
            >
              Research Microsoft
        </Button>
      </div>
         </div>
      </div>
    </div>
); 
} 